<!DOCTYPE html>
<html lang="en-US">
    <head>
        <meta charset="utf-8"> 
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="author" content="john pfeiffer" />
        <meta name="copyright" content="john pfeiffer" />

<meta name="keywords" content="cache, caching, redis, memcached, varnish, programming, " />
        <title>Caching data and common gotchas and an intro to redis memcached and varnish  · johnpfeiffer
</title>
        <link href="https://cdn-images.mailchimp.com/embedcode/slim-081711.css" rel="stylesheet" type="text/css">
        <link href="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.3.1/css/bootstrap-combined.min.css" rel="stylesheet">
        <link rel="stylesheet" type="text/css" href="https://blog.john-pfeiffer.com/theme/css/style.css" media="screen">
        <link rel="stylesheet" type="text/css" href="https://blog.john-pfeiffer.com/theme/css/solarizedlight.css" media="screen">
        <link rel="shortcut icon" href="https://blog.john-pfeiffer.com/theme/images/favicon.ico" type="image/x-icon" />
        <link rel="apple-touch-icon" href="https://blog.john-pfeiffer.com/theme/images/apple-touch-icon.png" />
        <link rel="apple-touch-icon" sizes="57x57" href="https://blog.john-pfeiffer.com/theme/images/apple-touch-icon-57x57.png" />
        <link rel="apple-touch-icon" sizes="72x72" href="https://blog.john-pfeiffer.com/theme/images/apple-touch-icon-72x72.png" />
        <link rel="apple-touch-icon" sizes="114x114" href="https://blog.john-pfeiffer.com/theme/images/apple-touch-icon-114x114.png" />
        <link rel="apple-touch-icon" sizes="144x144" href="https://blog.john-pfeiffer.com/theme/images/apple-touch-icon-144x144.png" />
        <link rel="icon" href="https://blog.john-pfeiffer.com/theme/images/apple-touch-icon-144x144.png" />
    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-3758734-9']);
    _gaq.push(['_trackPageview']);
    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
    </script>
    </head>
    <body>
	<div id="content-sans-footer">
        <div class="dropdown-backdrop">

			<div class="navbar navbar-static-top">
				<div class="navbar-inner">
					<div class="container">
						<a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
							<span class="icon-bar"></span>
							<span class="icon-bar"></span>
							<span class="icon-bar"></span>
						</a>
						<a class="brand" href="https://blog.john-pfeiffer.com/"><span class=site-name>johnpfeiffer</span></a>
						<div class="nav-collapse collapse">
							<ul class="nav pull-right top-menu">
								<li ><a href="https://blog.john-pfeiffer.com">Home</a></li>
								<li ><a href="https://blog.john-pfeiffer.com/john-likes/">John Likes</a></li>
								<li ><a href="https://blog.john-pfeiffer.com/categories.html">Categories</a></li>
								<li ><a href="https://blog.john-pfeiffer.com/tags.html">Tags</a></li>
								<li ><a href="https://blog.john-pfeiffer.com/archives.html">Archives</a></li>
								<li><form class="navbar-search" action="https://blog.john-pfeiffer.com/search.html" onsubmit="return validateForm(this.elements['q'].value);"> <input type="text" class="search-query" placeholder="Search" name="q" id="tipue_search_input"></form></li>
							</ul>
						</div>
					</div>
				</div>
			</div>
		</div>
		<div class="container-fluid">
			<div class="row-fluid">
				<div class="span1"></div>
				<div class="span10">
<article>
<div class="row-fluid">
    <header class="page_header span10 offset2">
    <h1><a href="https://blog.john-pfeiffer.com/caching-data-and-common-gotchas-and-an-intro-to-redis-memcached-and-varnish/"> Caching data and common gotchas and an intro to redis memcached and varnish  </a></h1>
    </header>
</div>

<div class="row-fluid">
    <div class="span2 table-of-content">
        <nav>
        <h4>Contents</h4>
        <div class="toc">
<ul>
<li><a href="#why-cache">Why Cache?</a><ul>
<li><a href="#questions-to-ask-when-caching">Questions to ask when caching</a></li>
<li><a href="#cache-latency-times-in-perspective">Cache Latency Times in Perspective</a></li>
<li><a href="#caches-are-another-operational-component-with-overhead">Caches are another Operational component with Overhead</a></li>
</ul>
</li>
<li><a href="#how-to-cache">How to Cache</a><ul>
<li><a href="#cache-on-write">Cache on Write</a></li>
<li><a href="#cache-on-read">Cache on Read</a></li>
</ul>
</li>
<li><a href="#common-gotchas">Common Gotchas</a><ul>
<li><a href="#cache-on-write-gotchas">Cache on write gotchas</a></li>
<li><a href="#expiration-cache-full-of-stale-junk">Expiration: cache full of stale junk</a></li>
<li><a href="#cold-cache-and-the-thundering-herd">Cold Cache and the Thundering Herd</a></li>
</ul>
</li>
<li><a href="#tools-for-caching">Tools for caching</a><ul>
<li><a href="#redis-examples">Redis Examples</a><ul>
<li><a href="#interactive-redis-prompt">Interactive Redis Prompt</a></li>
<li><a href="#non-interactive-redis-commands">Non Interactive Redis Commands</a></li>
</ul>
</li>
<li><a href="#installing-redis">Installing Redis</a><ul>
<li><a href="#redis-clients">Redis Clients</a></li>
</ul>
</li>
<li><a href="#memcached">Memcached</a></li>
<li><a href="#varnish">Varnish</a></li>
</ul>
</li>
</ul>
</div>
        </nav>
    </div>
    <div class="span8 article-content">

            
<p><strong>Caching is when you use a copy of a data set rather than using the source.</strong></p>
<p>Caching often involves a "Key Value Lookup":</p>
<ol>
<li>A request is received and the service checks the cache using a Key</li>
<li>The cache does not contain the Key</li>
<li>The service generates the result from the originating data source (i.e. database)</li>
<li>The service then stores the result in the cache with the Key as the index (and the result as the Value)</li>
<li>A request is received and the service checks the cache using a Key</li>
<li>The cache <strong>does</strong> contain the Key</li>
<li>The service retrieves the Value from the cache and returns the result</li>
</ol>
<p>A more concrete example would be to cache a User object by Email, so that whenever a request came in for a particular Users details the cache would contain their Name, Address, and Phone Number.</p>
<p><a href="https://en.wikipedia.org/wiki/Associative_array">https://en.wikipedia.org/wiki/Associative_array</a></p>
<h2 id="why-cache">Why Cache?</h2>
<p>A tradeoff of memory for cpu (or latency or some other business cost).</p>
<ul>
<li>accessing the data from source is too slow</li>
<li>the data actually comes from multiple sources (complex and expensive to retrieve)</li>
<li>to reduce load on the service originating data</li>
<li>to reduce contention (i.e. reads and writes)</li>
<li>for a client-server architecture, caching on the client reduces the number of required connections to a server</li>
<li>server side caching can protect backend resources and improve throughput and performance</li>
<li>computation is expensive (in terms of cpu, time, or money)</li>
</ul>
<h3 id="questions-to-ask-when-caching">Questions to ask when caching</h3>
<ul>
<li>Is the complexity of caching worth the performance gain? (simpler is often better)</li>
<li>Does my cache need to be consistent? (meaning the cache and data source return identical results)</li>
<li>Can my cache be "eventually consistent"? (meaning a wrong answer for some specified period of time is ok)</li>
<li>Am I caching at a high level? (meaning aggregating a lot of work/responses from lower level systems)</li>
<li>Am I caching at a low level? (meaning inside of my Data Access Object pattern I'm protecting a single simple resource, i.e. a MySQL table, from being accessed too often)</li>
<li>How unique are my Keys in my cache (i.e. if multiple users can have the same identifier it would be very bad to return the wrong session to the wrong user)</li>
</ul>
<h3 id="cache-latency-times-in-perspective">Cache Latency Times in Perspective</h3>
<p>Taking "why cache" to another level, the relative speeds of different cache levels highlight why some applications or algorithms will fail if they do not leverage cache.</p>
<ul>
<li>If your application is a very large amount of data the network may actually be better than disk; optimization would probably not be focused on "loop unrolling"</li>
<li>
<p>If your application depends on data across the internet then network caching, routing algorithms, and data modeling (eventual consistency!) may be more important than "tail recursion vs iterative"</p>
<p>A typical cpu instruction                    1   ns                              1 second basis (approximations)
L1 cache fetch                               0.5 ns                            <br/>
Branch mispredict                            4   ns
L2 cache fetch                               7   ns                              7 seconds
Mutex lock/unlock                           25   ns
RAM "main memory" fetch                    100   ns        0.1 us               2 minutes
Read 4K randomly from SSD              100,000   ns      100 us                 28 hours
Read 1 MB sequentially from memory     250,000   ns      250 us                 3 days
Send 1000 bytes over 1 Gbps network    500,000   ns      500 us     0.5 ms      6 days
Read 1 MB sequentially from SSD      1,000,000   ns    1,000 us     1 ms        12 days
Spinning Hard Disk seek              8,000,000   ns    8,000 us     8 ms        3 months
Read 1 MB sequentially from disk    20,000,000   ns   20,000 us    20 ms        7.6 months
Roundtrip SF to NY                  70,000,000   ns   70,000 us    70 ms        2 years
Roundtrip SF to Vienna             150,000,000   ns  150,000 us   150 ms        5 years</p>
</li>
</ul>
<blockquote>
<p>The L1 cache is the memory cache integrated into the CPU that is closest</p>
<p>Light travels 30 cm or about 1 foot in 1 nanosecond </p>
<p>ns = nanoseconds, us = microseconds, ms = milliseconds</p>
</blockquote>
<ul>
<li><a href="http://norvig.com/21-days.html#answers">http://norvig.com/21-days.html#answers</a> Peter Norvig</li>
<li><a href="https://en.wikipedia.org/wiki/CPU_cache">https://en.wikipedia.org/wiki/CPU_cache</a></li>
<li><a href="https://en.wikipedia.org/wiki/Solid-state_drive#Controller">https://en.wikipedia.org/wiki/Solid-state_drive#Controller</a></li>
<li><a href="http://www.codingblocks.net/podcast/episode-45-caching-overview-and-hardware/">http://www.codingblocks.net/podcast/episode-45-caching-overview-and-hardware/</a></li>
<li><a href="https://wondernetwork.com/pings">https://wondernetwork.com/pings</a></li>
<li><a href="https://twitter.com/rzezeski/status/398306728263315456/photo/1">https://twitter.com/rzezeski/status/398306728263315456/photo/1</a> Brendan Gregg</li>
</ul>
<h3 id="caches-are-another-operational-component-with-overhead">Caches are another Operational component with Overhead</h3>
<p>The best advice is to definitely avoiding caching until the last possible moment ("premature optimization" and "defer architecture decisions")</p>
<p>Not only do you have to write code complexity for using a cache, there's the nitty gritty of running a cache (which can be a completely different expertise than programming)</p>
<ul>
<li>Install</li>
<li>Upgrades</li>
<li>Security</li>
<li>Monitoring</li>
<li>Metrics</li>
</ul>
<p>None of this operational cost is free, and there are plenty of issues when just implementing caching in code...</p>
<h2 id="how-to-cache">How to Cache</h2>
<h3 id="cache-on-write">Cache on Write</h3>
<p>Also known as "cache on write through"</p>
<p>Whenever new data is written a cache must also be updated.</p>
<h3 id="cache-on-read">Cache on Read</h3>
<p>Also known as "cache on read through"</p>
<p>Whenever a query is made first the cache is checked.  If there is a "cache miss" then the data source is queried and the cache is updated and the result is returned.  If there is a "cache hit" and the data is in the cache then it is returned (and potentially a cache key expiration updated as this cache hit improved the cache efficiency).</p>
<h2 id="common-gotchas">Common Gotchas</h2>
<p>Caching is challenging because of the need for data consistency, parallel requests, and race conditions.</p>
<p>One good way to think about it is a banking system with money: if two people both try and empty an account at an ATM at the same time how will your caching system handle it?</p>
<h3 id="cache-on-write-gotchas">Cache on write gotchas</h3>
<p>One implementation flaw is to update the cache first; if the update to the data source fails then some requests may have been given incorrect data.</p>
<p>Another flaw would be to not have a "transaction" defined around both the update of the data and then the update of the cache since if either fails future requests will receive inconsistent results.</p>
<p>There may be a design mismatch as since data is only cached on write, if reads are occurring mostly on data written a long time ago they will be expired/pushed out and you will have poor cache efficiency.</p>
<p>While "cache on write" is a sometimes band-aid for NoSQL "eventual consistency" when it fails (i.e. all applications should expect that a cache will not exist or have a cache miss) the result may be data inconsistency.</p>
<p>One workaround is "check and set" (or "compare and set") where the cache will auto-invalidate if two conflicting entries are attempted.</p>
<p><a href="http://neopythonic.blogspot.com/2011/08/compare-and-set-in-memcache.html">http://neopythonic.blogspot.com/2011/08/compare-and-set-in-memcache.html</a></p>
<h3 id="expiration-cache-full-of-stale-junk">Expiration: cache full of stale junk</h3>
<p>A naive implementation of caching will store every result in the cache forever.  </p>
<p>While this seems like a good idea ("The cache application/service will just evict unused items based some algorithm") it is essentially forcing your cache to be full of potentially low value information on the hope that someone else will solve the problem.</p>
<p>Since some caching tools/framework do not set a default <strong>Time To Live</strong> or <strong>Expiration</strong> and in that case all of your data may quickly fill up the cache (not a bad thing per se), but then it will use whatever default or global "eviction policy" that is defined.</p>
<p>Applying business logic and empirical data to pick sane expiration values might not only improve cache performance but may protect your service from security issues or bugs due to serving really stale data.</p>
<blockquote>
<p>e.g. for security reasons, <strong>caching a session "forever" is a bad idea</strong> as an attacker may get access to an old client cache or token and be able to impersonate a legimate user</p>
</blockquote>
<p>Set a TTL or Expiration whenever possible that matches your domain (i.e. for a session 1 day or 1 week).</p>
<p>If the Time to Live is too short then the cache may have very poor efficiency (items expire before they can generate even one cache hit)</p>
<h3 id="cold-cache-and-the-thundering-herd">Cold Cache and the Thundering Herd</h3>
<ol>
<li>If the cache is "cold", i.e. has not been populated, then all queries will go directly to the source</li>
<li>If the source is not prepared for the "thundering herd" of requests (that were usually handled by the cache) then the source may become overloaded and bad things will happen</li>
<li>It is therefore best practice to "warm the cache" by seeding data from the source into the cache before significant load events</li>
</ol>
<h2 id="tools-for-caching">Tools for caching</h2>
<p>Much like encryption it is probably a good idea to use a time tested product over writing your own implementation.</p>
<h3 id="redis-examples">Redis Examples</h3>
<p>One thing to think about is that local redis might be far more effective than remote over the network redis.</p>
<p>If your application can depend less shared state this is good because sharing is a nightmare for cache semantics and distributed computing.</p>
<p>Regardless of securing your remote cache you will always want to measure cache effectiveness.</p>
<ul>
<li><a href="http://redis.io/commands">http://redis.io/commands</a></li>
</ul>
<h4 id="interactive-redis-prompt">Interactive Redis Prompt</h4>
<div class="highlight"><pre><span></span>redis-cli
keys *
</pre></div>
<h4 id="non-interactive-redis-commands">Non Interactive Redis Commands</h4>
<div class="highlight"><pre><span></span>redis-cli KEYS *:*
redis-cli KEYS session:1:*
redis-cli hgetall session:1:web
redis-cli hgetall session:1:web:presence

redis-cli KEYS "session:3:*" | xargs redis-cli DEL   # then upgrade --restart

redis-cli KEYS session:1:*  | grep session:1:web-48    # user_session.py , when the hardcoded max of 10 simultaneous sessions is hit no more can be created
  session:1:web-48679:rooms
  session:1:web-48679:presence
  session:1:web-48679:message_ids
  session:1:web-48679

redis-cli zrange sessions:1 0 9
  1) "1:web"
  2) "1:web-48679"

# remove a session manually?
redis-cli zrem sessions:1 1:web-48679
redis-cli del   session:1:web-48679:rooms
redis-cli del   session:1:web-48679:presence
redis-cli del   session:1:web-48679:message_ids
redis-cli del   session:1:web-48679
</pre></div>
<hr/>
<h3 id="installing-redis">Installing Redis</h3>
<ul>
<li><a href="http://redis.io/topics/quickstart">http://redis.io/topics/quickstart</a></li>
<li>
<p><a href="http://packages.ubuntu.com/trusty/redis-server">http://packages.ubuntu.com/trusty/redis-server</a> (sudo apt-get install redis-server)</p>
<p>redis-cli -h example.com ping</p>
<blockquote>
<p>PONG , aka verify a remote server connectivity</p>
</blockquote>
</li>
</ul>
<h4 id="redis-clients">Redis Clients</h4>
<p><a href="http://redis.io/clients#python">http://redis.io/clients#python</a></p>
<div class="highlight"><pre><span></span>pip install redis
</pre></div>
<p><a href="https://pypi.python.org/pypi/redis">https://pypi.python.org/pypi/redis</a></p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">redis</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">redis</span><span class="o">.</span><span class="n">StrictRedis</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="s1">'localhost'</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">6379</span><span class="p">)</span>
<span class="n">r</span><span class="o">.</span><span class="n">flushall</span><span class="p">()</span>
</pre></div>
<h3 id="memcached">Memcached</h3>
<ul>
<li><a href="http://memcached.org">http://memcached.org</a></li>
<li><a href="https://en.wikipedia.org/wiki/Memcached">https://en.wikipedia.org/wiki/Memcached</a></li>
</ul>
<h3 id="varnish">Varnish</h3>
<ul>
<li><a href="https://www.varnish-cache.org/about">https://www.varnish-cache.org/about</a> REST web caching</li>
</ul>
            <aside>
            <hr/>
            <nav>
            <ul class="articles_timeline">
 
                <li class="previous_article">« <a href="https://blog.john-pfeiffer.com/subunit-and-subunit2junitxml-to-get-junitxml-test-result-output-from-unittest/" title="Previous: Subunit and Subunit2JunitXML to get JUnitXML test result output from UnitTest">Subunit and Subunit2JunitXML to get JUnitXML test result output from UnitTest</a></li>
 
                <li class="next_article"><a href="https://blog.john-pfeiffer.com/haproxy-in-docker/" title="Next: HAProxy in Docker">HAProxy in Docker</a> »</li>
            </ul>
            </nav>
            </aside>
        </div>
        <section>
        <div class="span2" style="float:right;font-size:0.9em;">
 
            <h4>Published</h4>
            <time pubdate="pubdate" datetime="2015-03-26T00:00:00-07:00">Mar 26, 2015</time>
            <h4>Category</h4>
            <a class="category-link" href="/categories.html#programming-ref">programming</a> 
            <h4>~1527 words</h4>
            <h4>Tags</h4>
            <ul class="list-of-tags tags-in-article"> 
                <li><a href="/tags.html#cache-ref">cache
                    <span>1</span>
</a></li>
                <li><a href="/tags.html#caching-ref">caching
                    <span>1</span>
</a></li>
                <li><a href="/tags.html#memcached-ref">memcached
                    <span>1</span>
</a></li>
                <li><a href="/tags.html#redis-ref">redis
                    <span>1</span>
</a></li>
                <li><a href="/tags.html#varnish-ref">varnish
                    <span>1</span>
</a></li>
            </ul>

        </div>
        </section>
</div>
</article>
				</div>
				<div class="span1"></div>
			</div>
		</div>
    </div>
<footer>
<div id="footer">
    <ul class="footer-content">
    </ul>
</div>
</footer>            <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/2.3.1/js/bootstrap.min.js"></script>
        <script>
            function validateForm(query)
            {
                return (query.length > 0);
            }
        </script>

    </body>
</html>