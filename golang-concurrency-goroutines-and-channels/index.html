<!DOCTYPE html>
<html lang="en-US">
    <head>
        <meta charset="utf-8"> 
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="author" content="john pfeiffer" />
        <meta name="copyright" content="john pfeiffer" />

<meta name="keywords" content="go, golang, goroutines, concurrency, channels, select, pipelines, programming, " />
        <title>Golang Concurrency Goroutines and Channels  · johnpfeiffer
</title>
        <!--link href="https://cdn-images.mailchimp.com/embedcode/slim-081711.css" rel="stylesheet" type="text/css"-->
        <!--link href="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.3.1/css/bootstrap-combined.min.css" rel="stylesheet"-->
        <link href="https://blog.john-pfeiffer.com/theme/css/bootstrap-combined.min.css" rel="stylesheet">
        <link rel="stylesheet" type="text/css" href="https://blog.john-pfeiffer.com/theme/css/style.css" media="screen">
        <link rel="stylesheet" type="text/css" href="https://blog.john-pfeiffer.com/theme/css/solarizedlight.css" media="screen">
        <link rel="shortcut icon" href="https://blog.john-pfeiffer.com/theme/images/favicon.ico" type="image/x-icon" />
        <link rel="apple-touch-icon" href="https://blog.john-pfeiffer.com/theme/images/apple-touch-icon.png" />
        <link rel="apple-touch-icon" sizes="57x57" href="https://blog.john-pfeiffer.com/theme/images/apple-touch-icon-57x57.png" />
        <link rel="apple-touch-icon" sizes="72x72" href="https://blog.john-pfeiffer.com/theme/images/apple-touch-icon-72x72.png" />
        <link rel="apple-touch-icon" sizes="114x114" href="https://blog.john-pfeiffer.com/theme/images/apple-touch-icon-114x114.png" />
        <link rel="apple-touch-icon" sizes="144x144" href="https://blog.john-pfeiffer.com/theme/images/apple-touch-icon-144x144.png" />
        <link rel="icon" href="https://blog.john-pfeiffer.com/theme/images/apple-touch-icon-144x144.png" />
    </head>
    <body>
	<div id="content-sans-footer">
        <div class="dropdown-backdrop">

			<div class="navbar navbar-static-top">
				<div class="navbar-inner">
					<div class="container">
						<a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
							<span class="icon-bar"></span>
							<span class="icon-bar"></span>
							<span class="icon-bar"></span>
						</a>
						<a class="brand" href="https://blog.john-pfeiffer.com/"><span class=site-name>johnpfeiffer</span></a>
						<div class="nav-collapse collapse">
							<ul class="nav pull-right top-menu">
								<li ><a href="https://blog.john-pfeiffer.com">Home</a></li>
								<li ><a href="https://blog.john-pfeiffer.com/engineering-people-managers/">Engineering (People) Managers</a></li>
								<li ><a href="https://blog.john-pfeiffer.com/john-likes/">John Likes</a></li>
								<li ><a href="https://blog.john-pfeiffer.com/software-engineer-favorites/">Software Engineer Favorites</a></li>
								<li ><a href="https://blog.john-pfeiffer.com/categories.html">Categories</a></li>
								<li ><a href="https://blog.john-pfeiffer.com/tags.html">Tags</a></li>
								<li ><a href="https://blog.john-pfeiffer.com/archives.html">Archives</a></li>
								<li><form class="navbar-search" action="https://blog.john-pfeiffer.com/search.html" onsubmit="return validateForm(this.elements['q'].value);"> <input type="text" class="search-query" placeholder="Search" name="q" id="tipue_search_input"></form></li>
							</ul>
						</div>
					</div>
				</div>
			</div>
		</div>
		<div class="container-fluid">
			<div class="row-fluid">
				<div class="span1"></div>
				<div class="span10">
<article>
<div class="row-fluid">
    <header class="page_header span10 offset2">
    <h1><a href="https://blog.john-pfeiffer.com/golang-concurrency-goroutines-and-channels/"> Golang Concurrency Goroutines and Channels  </a></h1>
    </header>
</div>

<div class="row-fluid">
    <div class="span2 table-of-content">
        <nav>
        <h4>Contents</h4>
        <div class="toc">
<ul>
<li><a href="#go-and-goroutines">Go and Goroutines</a></li>
<li><a href="#sync-with-a-waitgroup">Sync with a WaitGroup</a></li>
<li><a href="#channels">Channels</a><ul>
<li><a href="#buffered-channels-and-returning-a-value">Buffered channels and returning a value</a></li>
<li><a href="#using-select-to-not-block-a-channel">Using Select to not block a channel</a></li>
<li><a href="#real-example-of-concurrency-in-a-lan-scanner">Real Example of Concurrency in a LAN Scanner</a></li>
<li><a href="#troubleshooting-race-conditions">Troubleshooting Race Conditions</a></li>
<li><a href="#more-random-thoughts-on-concurrency-and-control">More random thoughts on concurrency and control</a><ul>
<li><a href="#an-important-consideration-to-termination-is-cleanup">An important consideration to termination is cleanup</a></li>
<li><a href="#poison-jobs-cons-and-pros">Poison Jobs cons and pros</a></li>
<li><a href="#patterns-for-channels-and-flow-control">Patterns for Channels and Flow Control</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
        </nav>
    </div>
    <div class="span8 article-content">

            
<p>If there is a killer feature to Go it is the focus on concurrency.  This article captures some of the basics and I hope to someday write a follow-up article on more advanced topics.</p>
<blockquote>
<p>"Go is a compiled, concurrent, garbage-collected, statically typed language"</p>
</blockquote>
<ul>
<li><a href="https://talks.golang.org/2012/splash.article">https://talks.golang.org/2012/splash.article</a></li>
</ul>
<p>Distributed systems and large data sizes mean developers are forced to think in parallelism, or are they?</p>
<p>Using Go channels (based upon Communicating Sequential Processes <a href="https://en.wikipedia.org/wiki/Communicating_sequential_processes">https://en.wikipedia.org/wiki/Communicating_sequential_processes</a>, <a href="http://www.cs.cmu.edu/~crary/819-f09/Hoare78.pdf">http://www.cs.cmu.edu/~crary/819-f09/Hoare78.pdf</a>) developers can write code that feels very imperative and sequential, but designed in such a way that parallelism comes easily.</p>
<ul>
<li><a href="https://golang.org/doc/effective_go.html#concurrency">https://golang.org/doc/effective_go.html#concurrency</a></li>
<li><a href="https://blog.golang.org/concurrency-is-not-parallelism">https://blog.golang.org/concurrency-is-not-parallelism</a></li>
</ul>
<h2 id="go-and-goroutines">Go and Goroutines</h2>
<p>A goroutine is a "lightweight thread" that allows for a far higher amount of concurrency than just depending on OS processes or even traditional threading (and much simpler than attempting to explicitly organize around a defined number of processors or threads).</p>
<p>In a very meta sense every Go program uses concurrency because the main function itself is an implicit goroutine (and will not wait or might block forever ;)</p>
<div class="highlight"><pre><span></span><code><span class="kn">package</span><span class="w"> </span><span class="nx">main</span>

<span class="kn">import</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="s">"fmt"</span>
<span class="w">    </span><span class="s">"time"</span>
<span class="p">)</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">example</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">"example"</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">go</span><span class="w"> </span><span class="nx">example</span><span class="p">()</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">"done"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<blockquote>
<p>This will exit without printing "example" because using the "go" keyword runs the example function in a new goroutine</p>
</blockquote>
<ul>
<li><a href="https://play.golang.org/p/h6_B0whHxE">https://play.golang.org/p/h6_B0whHxE</a></li>
<li><a href="https://golang.org/pkg/testing/#hdr-Main">https://golang.org/pkg/testing/#hdr-Main</a></li>
<li><a href="http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/">http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/</a></li>
<li><a href="https://en.wikipedia.org/wiki/Green_threads">https://en.wikipedia.org/wiki/Green_threads</a></li>
</ul>
<blockquote>
<p>There is no explicit external management of a goroutine once it has started, terminating a goroutine is implemented via an exception or exit in the code that the goroutine is running, usually signalled via a channel</p>
</blockquote>
<p>Since Goroutines are cooperative they are not pre-empt-able...</p>
<ul>
<li><a href="https://dave.cheney.net/2016/12/22/never-start-a-goroutine-without-knowing-how-it-will-stop">https://dave.cheney.net/2016/12/22/never-start-a-goroutine-without-knowing-how-it-will-stop</a></li>
<li><a href="https://en.wikipedia.org/wiki/Preemption_(computing)">https://en.wikipedia.org/wiki/Preemption_(computing)</a></li>
<li><a href="https://github.com/golang/go/issues/10958">https://github.com/golang/go/issues/10958</a></li>
</ul>
<h2 id="sync-with-a-waitgroup">Sync with a WaitGroup</h2>
<p>The most straightforward way to fix the previous trivial example is to specify in advance that the implicit main goroutine should wait before continuing...</p>
<div class="highlight"><pre><span></span><code><span class="kn">package</span><span class="w"> </span><span class="nx">main</span>

<span class="kn">import</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="s">"fmt"</span>
<span class="w">    </span><span class="s">"sync"</span>
<span class="w">    </span><span class="s">"time"</span>
<span class="p">)</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">example</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">"example"</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">wg</span><span class="w"> </span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
<span class="w">    </span><span class="nx">wg</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">example</span><span class="p">()</span>
<span class="w">        </span><span class="nx">wg</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>
<span class="w">    </span><span class="p">}()</span>
<span class="w">    </span><span class="nx">wg</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">"done"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<blockquote>
<ol>
<li>The example function remains unchanged</li>
<li>The waitgroup will expect one call of "Done"</li>
<li>The go keyword now calls an anonymous function that calls wg.Done() (accessed using closure) after example()</li>
<li>The waitgroup.Wait() blocks until the correct number of Done() calls have been made</li>
<li>The example function sleep and print finally finish</li>
<li>The waitgroup unblocks and the main goroutine can finally print "done" and exit</li>
</ol>
</blockquote>
<ul>
<li><a href="https://play.golang.org/p/p0jDoiGBT4">https://play.golang.org/p/p0jDoiGBT4</a></li>
<li><a href="https://golang.org/pkg/sync/#example_WaitGroup">https://golang.org/pkg/sync/#example_WaitGroup</a></li>
</ul>
<h2 id="channels">Channels</h2>
<p>Channels are the recommended way of communicating when using goroutines (and sharing resources).</p>
<blockquote>
<p>&lt;- the arrow always points to the left</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="kn">package</span><span class="w"> </span><span class="nx">main</span>

<span class="kn">import</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="s">"fmt"</span>
<span class="w">    </span><span class="s">"time"</span>
<span class="p">)</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">c</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span>
<span class="w">    </span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">"sleeping..."</span><span class="p">)</span>
<span class="w">        </span><span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="w">        </span><span class="nx">c</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">42</span>
<span class="w">        </span><span class="nb">close</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span><span class="w">  </span><span class="c1">// IF NOT CLOSED THEN DEADLOCK</span>
<span class="w">        </span><span class="c1">// c &lt;- 2  DO NOT SEND TO A CLOSED CHANNEL, IT WILL PANIC</span>
<span class="w">    </span><span class="p">}()</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">"anonymous function, a channel passed a value via closure"</span><span class="p">,</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">c</span><span class="p">)</span>
<span class="w">    </span><span class="nx">v</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">c</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<blockquote>
<ul>
<li>since a channel is a reference type "make" is used and the &lt;- sends a value to the channel, later &lt;- is used to receive a value</li>
<li>a closed channel cannot be written to further and will PANIC "send on a closed channel"</li>
<li>if you forget to close a channel, later reading from an open unbuffered channel which does not have data will exit "fatal error: all goroutines are asleep - deadlock!"</li>
<li>an "unbuffered" channel "blocks" until both the sender and receiver are ready</li>
<li>the Println function reads from the channel, in this case the channel acts as a synchronization tool that blocks at the Print statement and prevents the main goroutine from exiting</li>
<li>The final printed output will be: "0 false", since the channel is closed and empty subsequent receives will return a the empty value "zero" and the state of the channel (in this case "false")</li>
</ul>
</blockquote>
<ul>
<li><a href="https://play.golang.org/p/RR0PWmAeKa">https://play.golang.org/p/RR0PWmAeKa</a></li>
<li><a href="https://gobyexample.com/channels">https://gobyexample.com/channels</a></li>
<li><a href="https://dave.cheney.net/2013/04/30/curious-channels">https://dave.cheney.net/2013/04/30/curious-channels</a></li>
</ul>
<h3 id="buffered-channels-and-returning-a-value">Buffered channels and returning a value</h3>
<p>A common problem is one part of the application running faster than another part and one way to "unblock" the fast part is to use a buffer to create a queue for the slower part to catch up.
This kind of issue occurs in a "pipeline" of producers/consumers (also known as sources/sinks)...</p>
<div class="highlight"><pre><span></span><code><span class="kn">package</span><span class="w"> </span><span class="nx">main</span>

<span class="kn">import</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="s">"fmt"</span>
<span class="w">    </span><span class="s">"log"</span>
<span class="w">    </span><span class="s">"sync"</span>
<span class="w">    </span><span class="s">"time"</span>
<span class="p">)</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">slowReceiver</span><span class="p">(</span><span class="nx">c</span><span class="w"> </span><span class="o">&lt;-</span><span class="kd">chan</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="nx">wg</span><span class="w"> </span><span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">n</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">c</span>
<span class="w">        </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">"received"</span><span class="p">,</span><span class="w"> </span><span class="nx">n</span><span class="p">)</span>
<span class="w">        </span><span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="w">        </span><span class="c1">// c &lt;- 42 // THIS WOULD CAUSE AN ERROR "(send to receive-only type &lt;-chan int)"</span>
<span class="w">        </span><span class="nx">wg</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">fastSender</span><span class="p">(</span><span class="nx">c</span><span class="w"> </span><span class="kd">chan</span><span class="o">&lt;-</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="nx">wg</span><span class="w"> </span><span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">c</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nx">i</span>
<span class="w">        </span><span class="nx">wg</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="w">        </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
<span class="w">        </span><span class="c1">// fmt.Println(&lt;-c) // THIS WOULD CAUSE AN ERROR "(receive from send-only type chan&lt;- int)"</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">start</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">()</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">wg</span><span class="w"> </span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
<span class="w">    </span><span class="nx">c</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span>
<span class="w">    </span><span class="k">go</span><span class="w"> </span><span class="nx">slowReceiver</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">wg</span><span class="p">)</span>
<span class="w">    </span><span class="nx">fastSender</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">wg</span><span class="p">)</span>
<span class="w">    </span><span class="nx">wg</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span>
<span class="w">    </span><span class="nx">log</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Since</span><span class="p">(</span><span class="nx">start</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div>
<blockquote>
<ul>
<li>This example shows how to specify a channel of type that either only sends or only receives</li>
<li>log works the same as fmt and Since() a very convenient way to output elapsed time</li>
<li>Without the waitgroup Wait() main would exit after 1 second with only "received 1" and never reach "received 4" (5 seconds)</li>
</ul>
</blockquote>
<ul>
<li><a href="https://blog.golang.org/pipelines">https://blog.golang.org/pipelines</a></li>
<li><a href="https://play.golang.org/p/NcEOgCiSQs">https://play.golang.org/p/NcEOgCiSQs</a></li>
<li><a href="https://tour.golang.org/concurrency/3">https://tour.golang.org/concurrency/3</a></li>
</ul>
<h3 id="using-select-to-not-block-a-channel">Using Select to not block a channel</h3>
<p>Channels are most useful when they can block asynchronously until an event occurs.</p>
<div class="highlight"><pre><span></span><code><span class="n">package</span><span class="w"> </span><span class="n">main</span>

<span class="kn">import</span><span class="w"> </span><span class="s2">"time"</span>
<span class="kn">import</span><span class="w"> </span><span class="s2">"fmt"</span>

<span class="n">func</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">c</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">make</span><span class="p">(</span><span class="n">chan</span><span class="w"> </span><span class="n">string</span><span class="p">)</span>
<span class="w">    </span><span class="n">q</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">make</span><span class="p">(</span><span class="n">chan</span><span class="w"> </span><span class="nb">bool</span><span class="p">)</span>
<span class="w">    </span><span class="n">go</span><span class="w"> </span><span class="n">myDelayedQuit</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
<span class="w">    </span><span class="n">go</span><span class="w"> </span><span class="n">mySleep</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>

<span class="w">    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s2">"begin non blocking wait..."</span><span class="p">)</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">select</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">case</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&lt;-</span><span class="n">c</span><span class="p">:</span>
<span class="w">            </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s2">"received:"</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">)</span>
<span class="w">        </span><span class="n">case</span><span class="w"> </span><span class="o">&lt;-</span><span class="n">q</span><span class="p">:</span>
<span class="w">            </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s2">"done"</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="n">func</span><span class="w"> </span><span class="n">mySleep</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="n">chan</span><span class="w"> </span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="nb">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">time</span><span class="o">.</span><span class="n">Duration</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
<span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="s2">"woke up"</span>
<span class="p">}</span>

<span class="n">func</span><span class="w"> </span><span class="n">myDelayedQuit</span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="n">chan</span><span class="w"> </span><span class="nb">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">    </span><span class="n">b</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">true</span>
<span class="p">}</span>
</code></pre></div>
<blockquote>
<ul>
<li><strong>for</strong> loops forever until the return statement</li>
<li><strong>select</strong> will wait and whenever a case can be filled it will unblock</li>
<li>after 1 second the sleep function is done and sends the "woke up" message</li>
<li>after 2 seconds the true boolean is sent and main finishes</li>
</ul>
</blockquote>
<ul>
<li><a href="https://play.golang.org/p/JBrhHZVq6a">https://play.golang.org/p/JBrhHZVq6a</a></li>
</ul>
<h3 id="real-example-of-concurrency-in-a-lan-scanner">Real Example of Concurrency in a LAN Scanner</h3>
<p>A real world example is discovering all of the hosts listening on a given port in local area network (subnet).</p>
<p>In a serial example waiting 2 seconds for each host to respond would mean waiting 512 seconds in a "normal" /24 subnet of ~256 hosts (ignoring the .255 broadcast and .0)</p>
<div class="highlight"><pre><span></span><code><span class="nx">found</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="nx">IPCheckResult</span><span class="p">,</span><span class="w"> </span><span class="nx">max</span><span class="p">)</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">wg</span><span class="w"> </span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
<span class="nx">wg</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="nx">max</span><span class="p">)</span>
<span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">addresses</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">"checking"</span><span class="p">,</span><span class="w"> </span><span class="nx">a</span><span class="p">)</span>
<span class="w">    </span><span class="c1">// https://golang.org/doc/faq#closures_and_goroutines</span>
<span class="w">    </span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">ip</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">checkIP</span><span class="p">(</span><span class="nx">ip</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="nx">port</span><span class="p">,</span><span class="w"> </span><span class="nx">found</span><span class="p">)</span>
<span class="w">        </span><span class="nx">wg</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>
<span class="w">    </span><span class="p">}(</span><span class="nx">a</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">wg</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span>
<span class="nb">close</span><span class="p">(</span><span class="nx">found</span><span class="p">)</span>
</code></pre></div>
<blockquote>
<p>Here the channel is simply used as a "lock free" place to aggregate all of the results of the goroutines, sync occurs via the waitgroup which will wait until every pre-added item is decremented by a Done(), there is definitely a possibility for an off-by-one gotcha that will hang your program!</p>
</blockquote>
<p><a href="https://bitbucket.org/johnpfeiffer/go-lanscan/src">https://bitbucket.org/johnpfeiffer/go-lanscan/src</a></p>
<h3 id="troubleshooting-race-conditions">Troubleshooting Race Conditions</h3>
<p>A common gotcha is that in Go maps are not safe for concurrent use:</p>
<ul>
<li><a href="https://blog.golang.org/go-maps-in-action">https://blog.golang.org/go-maps-in-action</a></li>
<li><a href="https://golang.org/doc/faq#atomic_maps">https://golang.org/doc/faq#atomic_maps</a></li>
</ul>
<p>In this example of a simple in memory cache the expiration was implemented...</p>
<div class="highlight"><pre><span></span><code><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">memory</span><span class="w"> </span><span class="nx">MemoryCache</span><span class="p">)</span><span class="w"> </span><span class="nx">Set</span><span class="p">(</span><span class="nx">key</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">expiresSeconds</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">memory</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">value</span>
<span class="w">    </span><span class="nx">timer</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">time</span><span class="p">.</span><span class="nx">NewTimer</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">(</span><span class="nx">expiresSeconds</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="w">    </span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="o">&lt;-</span><span class="nx">timer</span><span class="p">.</span><span class="nx">C</span>
<span class="w">        </span><span class="nx">memory</span><span class="p">.</span><span class="nx">Delete</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
<span class="w">        </span><span class="c1">// log.Println("Timer triggered cache expiration for", key)</span>
<span class="w">    </span><span class="p">}()</span>
<span class="p">}</span>
</code></pre></div>
<blockquote>
<p>The error here is that the goroutine that wakes up to "expire" and remove a key/value pair from the map may contend with any other later operation (i.e. Get, Set, Delete) that is also modifying the map</p>
</blockquote>
<ul>
<li><a href="https://bitbucket.org/johnpfeiffer/go-cache/src">https://bitbucket.org/johnpfeiffer/go-cache/src</a></li>
</ul>
<p>A really helpful tool is to run <code>go test -race</code> , it may take a little bit but "WARNING: DATA RACE" is pretty clear.</p>
<ul>
<li><a href="https://blog.golang.org/race-detector">https://blog.golang.org/race-detector</a></li>
</ul>
<h3 id="more-random-thoughts-on-concurrency-and-control">More random thoughts on concurrency and control</h3>
<p>Controlling goroutines is like controlling threads or even any other control flow.</p>
<p>Iterative vs Recursive calculation of factorial means either predetermined count of iterations or an indeterminate count (recursion) with a (base case) signal for termination (often called a sentinel value).</p>
<p>So either the External Controller knows when to stop or each actor checks if it is time to stop.</p>
<h4 id="an-important-consideration-to-termination-is-cleanup">An important consideration to termination is cleanup</h4>
<p>If the actor is responsible for self cleanup (as it knows what resources it is using) this can lead to resource leaks if the actor terminates unexpectedly without cleaning up.</p>
<p>If using "dependency injection" then the Controller has knowledge of what resources were shared with the agents and can do cleanup, even if actors terminate unexpectedly.</p>
<p>An increasingly common approach is for the Framework to facilitate cleanup so that the complexity is removed from both the Controller and the actors (e.g. Garbage Collection or Go deferred)</p>
<h4 id="poison-jobs-cons-and-pros">Poison Jobs cons and pros</h4>
<p>One challenge with workers and a queue is the "poison job" which may create inefficiency or halt the system entirely as each worker who takes the job blocks/loops forever or terminates unexpectedly.</p>
<p>One possible solution is to have a retry count so that any job which has timed out or failed and retried repeatedly is moved to a FailedJob queue (for future manual inspection and debugging) or logged and dropped entirely.</p>
<p>Interestingly something like a "poison job" is actually a useful way to signal to concurrent actors to have an orderly termination even if they have not completed their jobs (i.e. a full system shutdown has been initiated and we want to trigger self cleanup).</p>
<h4 id="patterns-for-channels-and-flow-control">Patterns for Channels and Flow Control</h4>
<p>Go Channels represent a way to map out the dependencies and then allow the compiler to optimize for parallelization.</p>
<p>Waiting indefinitely for all goroutines to return is naive, and any termination signal must have the ability to truly interrupt work in progress, which it does NOT for goroutines, so any call that a goroutine is making MUST have a timebound where it can check for the termination signal.</p>
<p>Therefore write your goroutines carefully knowing that you cannot cancel/aka force them to return from an infinite loop/long call, unless you exit main entirely.</p>
<p>This means that for architecture decisions it is important to consider small separate services/applications that can provide resource usage transparency and termination control.  While this is becomes a tradeoff with coordination/orchestration complexity it is worth having modularity and clear boundaries in any application of decent complexity.</p>
<ul>
<li>Simple and deterministic: fan out with predefined count, close the channel</li>
<li>Provide timeouts and retries: a failure can occur anywhere and graceful degradation means setting limits and dealing with ephemeral errors</li>
<li>Use the select statement for a non-blocking way to check for early application termination events</li>
<li>Use buffers to even out spikes in work from sources/production</li>
</ul>
<p><a href="https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html">https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html</a></p>
            <aside>
            <hr/>
            <nav>
            <ul class="articles_timeline">
 
                <li class="previous_article">« <a href="https://blog.john-pfeiffer.com/code-is-for-humans/" title="Previous: Code is for Humans">Code is for Humans</a></li>
 
                <li class="next_article"><a href="https://blog.john-pfeiffer.com/mid-2017-technology-and-business-prediction-for-2018-and-beyond/" title="Next: Mid 2017 technology and business prediction for 2018 and beyond">Mid 2017 technology and business prediction for 2018 and beyond</a> »</li>
            </ul>
            </nav>
            </aside>
        </div>
        <section>
        <div class="span2" style="float:right;font-size:0.9em;">
 
            <h4>Published</h4>
            <time pubdate="pubdate" datetime="2017-04-12T22:54:00-07:00">Apr 12, 2017</time>
            <h4>Category</h4>
            <a class="category-link" href="/categories.html#programming-ref">programming</a> 
            <h4>~1642 words</h4>
            <h4>Tags</h4>
            <ul class="list-of-tags tags-in-article"> 
                <li><a href="/tags.html#channels-ref">channels
                    <span>1</span>
</a></li>
                <li><a href="/tags.html#concurrency-ref">concurrency
                    <span>2</span>
</a></li>
                <li><a href="/tags.html#go-ref">go
                    <span>16</span>
</a></li>
                <li><a href="/tags.html#golang-ref">golang
                    <span>16</span>
</a></li>
                <li><a href="/tags.html#goroutines-ref">goroutines
                    <span>2</span>
</a></li>
                <li><a href="/tags.html#pipelines-ref">pipelines
                    <span>2</span>
</a></li>
                <li><a href="/tags.html#select-ref">select
                    <span>1</span>
</a></li>
            </ul>

        </div>
        </section>
</div>
</article>
				</div>
				<div class="span1"></div>
			</div>
		</div>
    </div>
<footer>
<div id="footer">
    <ul class="footer-content">
    </ul>
</div>
</footer>            <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/2.3.1/js/bootstrap.min.js"></script>
        <script>
            function validateForm(query)
            {
                return (query.length > 0);
            }
        </script>

    </body>
</html>