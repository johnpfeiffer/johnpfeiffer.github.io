<!DOCTYPE html>
<html lang="en-US">
    <head>
        <meta charset="utf-8"> 
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="author" content="john pfeiffer" />
        <meta name="copyright" content="john pfeiffer" />

<meta name="keywords" content="go, golang, testing, benchmark, profiling, subtests, tdd, programming, " />
        <title>Golang Testing Benchmark Profiling Subtests Fuzz Testing  Â· johnpfeiffer
</title>
        <link href="https://cdn-images.mailchimp.com/embedcode/slim-081711.css" rel="stylesheet" type="text/css">
        <link href="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.3.1/css/bootstrap-combined.min.css" rel="stylesheet">
        <link rel="stylesheet" type="text/css" href="https://blog.john-pfeiffer.com/theme/css/style.css" media="screen">
        <link rel="stylesheet" type="text/css" href="https://blog.john-pfeiffer.com/theme/css/solarizedlight.css" media="screen">
        <link rel="shortcut icon" href="https://blog.john-pfeiffer.com/theme/images/favicon.ico" type="image/x-icon" />
        <link rel="apple-touch-icon" href="https://blog.john-pfeiffer.com/theme/images/apple-touch-icon.png" />
        <link rel="apple-touch-icon" sizes="57x57" href="https://blog.john-pfeiffer.com/theme/images/apple-touch-icon-57x57.png" />
        <link rel="apple-touch-icon" sizes="72x72" href="https://blog.john-pfeiffer.com/theme/images/apple-touch-icon-72x72.png" />
        <link rel="apple-touch-icon" sizes="114x114" href="https://blog.john-pfeiffer.com/theme/images/apple-touch-icon-114x114.png" />
        <link rel="apple-touch-icon" sizes="144x144" href="https://blog.john-pfeiffer.com/theme/images/apple-touch-icon-144x144.png" />
        <link rel="icon" href="https://blog.john-pfeiffer.com/theme/images/apple-touch-icon-144x144.png" />
    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-3758734-9']);
    _gaq.push(['_trackPageview']);
    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
    </script>
    </head>
    <body>
	<div id="content-sans-footer">
        <div class="dropdown-backdrop">

			<div class="navbar navbar-static-top">
				<div class="navbar-inner">
					<div class="container">
						<a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
							<span class="icon-bar"></span>
							<span class="icon-bar"></span>
							<span class="icon-bar"></span>
						</a>
						<a class="brand" href="https://blog.john-pfeiffer.com/"><span class=site-name>johnpfeiffer</span></a>
						<div class="nav-collapse collapse">
							<ul class="nav pull-right top-menu">
								<li ><a href="https://blog.john-pfeiffer.com">Home</a></li>
								<li ><a href="https://blog.john-pfeiffer.com/john-likes/">John Likes</a></li>
								<li ><a href="https://blog.john-pfeiffer.com/categories.html">Categories</a></li>
								<li ><a href="https://blog.john-pfeiffer.com/tags.html">Tags</a></li>
								<li ><a href="https://blog.john-pfeiffer.com/archives.html">Archives</a></li>
								<li><form class="navbar-search" action="https://blog.john-pfeiffer.com/search.html" onsubmit="return validateForm(this.elements['q'].value);"> <input type="text" class="search-query" placeholder="Search" name="q" id="tipue_search_input"></form></li>
							</ul>
						</div>
					</div>
				</div>
			</div>
		</div>
		<div class="container-fluid">
			<div class="row-fluid">
				<div class="span1"></div>
				<div class="span10">
<article>
<div class="row-fluid">
    <header class="page_header span10 offset2">
    <h1><a href="https://blog.john-pfeiffer.com/golang-testing-benchmark-profiling-subtests-fuzz-testing/"> Golang Testing Benchmark Profiling Subtests Fuzz Testing  </a></h1>
    </header>
</div>

<div class="row-fluid">
    <div class="span2 table-of-content">
        <nav>
        <h4>Contents</h4>
        <div class="toc">
<ul>
<li><a href="#small-functions-make-for-good-tests">Small functions make for good tests</a><ul>
<li><a href="#some-reasons-to-not-use-mega-objects">Some reasons to not use MEGA-OBJECTS</a></li>
</ul>
</li>
<li><a href="#example-function-with-go-unit-tests">Example function with go unit tests</a><ul>
<li><a href="#main_testgo">main_test.go</a><ul>
<li><a href="#running-a-specific-test">Running a specific test</a></li>
<li><a href="#test-coverage">Test Coverage</a></li>
</ul>
</li>
<li><a href="#subtests">Subtests</a><ul>
<li><a href="#running-a-specific-subtest">Running a specific subtest</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#benchmarking">Benchmarking</a><ul>
<li><a href="#running-specific-benchmarks">Running specific benchmarks</a></li>
</ul>
</li>
<li><a href="#profiling">Profiling</a></li>
<li><a href="#go-fuzz-testing">Go Fuzz Testing</a></li>
</ul>
</div>
        </nav>
    </div>
    <div class="span8 article-content">

            
<p>Go makes it very easy to unit test with the packagename_test.go file right next to the package source code file(s).</p>
<p>As a pragmatic language designed for developers who ship to production the amount of built in tooling (testing, benchmarks, etc.) is impressive.</p>
<p>Taking an earlier example I gave of MergeSort let's examine how TestDrivenDevelopment (or Design) was used to implement it.</p>
<h2 id="small-functions-make-for-good-tests">Small functions make for good tests</h2>
<p>Small functions are easier to read and code is read 1000 times more often than it is written. <em>(completely made up but believable fact).</em></p>
<p>Less lines of very-readable-code is usually an ok approximation for complexity, and less complexity means your program is easier to reason about (and easier to validate with tests!).</p>
<h3 id="some-reasons-to-not-use-mega-objects">Some reasons to not use MEGA-OBJECTS</h3>
<p>One of the things that TDD helps focus on is modularity and requirements.  Two tensions to balance are the needs of the caller versus the needs of the function.</p>
<p>What I mean is that the function caller wants to understand what they have to provide and what they'll get back.  If the function asks for a MEGA-OBJECT then somehow the caller has to find or create a MEGA-OBJECT (which sounds very expensive).  And if the function didn't really need the MEGA-OBJECT then the function will extract the one value it actually needs and throw all that work away.</p>
<p>If instead the function asks for the integer primitive that is the value of the MEGA-OBJECT's this should be very easy to fulfill.  (Which is how tests help discover this MEGA-OBJECT anti-pattern, because even MEGA-OBJECT mocks are difficult).</p>
<p>A second reason to not pass a MEGA-OBJECT is that those are usually "pass by reference" for performance reasons and if modifying/side-effects are allowed then the function may accidentally invalidate other values (or intentionally corrupt data or override permissions).</p>
<p>The less state being passed around the easier it is to quickly write a large base of non brittle unit tests to isolate exactly where the logic goes wrong when doing "the simplest thing" and of course to communicate to others/callers how they might use your function or how it handles failure modes.</p>
<ul>
<li><a href="http://martinfowler.com/bliki/TestPyramid.html">http://martinfowler.com/bliki/TestPyramid.html</a></li>
<li><a href="https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html">https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html</a></li>
</ul>
<h2 id="example-function-with-go-unit-tests">Example function with go unit tests</h2>
<p>This example function requires two slices of integers.</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">"fmt"</span>
<span class="p">)</span>

<span class="c1">// SlicesMerge takes two sorted slices of integers and merges them into a single sorted slice of integers</span>
<span class="kd">func</span> <span class="nx">SlicesMerge</span><span class="p">(</span><span class="nx">a</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">b</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="nx">s</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">))</span>
    <span class="k">for</span> <span class="nx">ai</span><span class="p">,</span> <span class="nx">bi</span><span class="p">,</span> <span class="nx">si</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">si</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">si</span><span class="o">--</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">ai</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nx">s</span><span class="p">[</span><span class="nx">si</span><span class="p">]</span> <span class="p">=</span> <span class="nx">b</span><span class="p">[</span><span class="nx">bi</span><span class="p">]</span>
            <span class="nx">bi</span><span class="o">--</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">bi</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nx">s</span><span class="p">[</span><span class="nx">si</span><span class="p">]</span> <span class="p">=</span> <span class="nx">a</span><span class="p">[</span><span class="nx">ai</span><span class="p">]</span>
            <span class="nx">ai</span><span class="o">--</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">a</span><span class="p">[</span><span class="nx">ai</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">b</span><span class="p">[</span><span class="nx">bi</span><span class="p">]</span> <span class="p">{</span>
            <span class="nx">s</span><span class="p">[</span><span class="nx">si</span><span class="p">]</span> <span class="p">=</span> <span class="nx">a</span><span class="p">[</span><span class="nx">ai</span><span class="p">]</span>
            <span class="nx">ai</span><span class="o">--</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">s</span><span class="p">[</span><span class="nx">si</span><span class="p">]</span> <span class="p">=</span> <span class="nx">b</span><span class="p">[</span><span class="nx">bi</span><span class="p">]</span>
            <span class="nx">bi</span><span class="o">--</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">a</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
    <span class="nx">b</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">"merged:"</span><span class="p">,</span> <span class="nx">SlicesMerge</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
<blockquote>
<p>a main function with print statements is the tried and true way of manual testing , <code>go run main.go</code></p>
</blockquote>
<h3 id="main_testgo">main_test.go</h3>
<blockquote>
<p>Automated units tests means another developer can fix a bug and ensure it does not regress, read and learn expected behavior, and of course have automated continuous integration catch problems as early as possible, <code>go test</code></p>
</blockquote>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">"reflect"</span>
    <span class="s">"testing"</span>
<span class="p">)</span>


<span class="kd">var</span> <span class="nx">nilslice</span> <span class="p">[]</span><span class="kt">int</span>

<span class="kd">var</span> <span class="nx">empty</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>

<span class="kd">func</span> <span class="nx">TestSlicesMergeEmpty</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>
    <span class="nx">assertSlicesEqual</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">empty</span><span class="p">,</span> <span class="nx">SlicesMerge</span><span class="p">(</span><span class="nx">empty</span><span class="p">,</span> <span class="nx">empty</span><span class="p">))</span>
    <span class="nx">assertSlicesEqual</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">empty</span><span class="p">,</span> <span class="nx">SlicesMerge</span><span class="p">(</span><span class="nx">empty</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
    <span class="nx">assertSlicesEqual</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">empty</span><span class="p">,</span> <span class="nx">SlicesMerge</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="nx">empty</span><span class="p">))</span>
    <span class="nx">assertSlicesEqual</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">empty</span><span class="p">,</span> <span class="nx">SlicesMerge</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">TestSlicesMergeHalfEmpty</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>
    <span class="nx">a</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">}</span>
    <span class="nx">assertSlicesEqual</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">SlicesMerge</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">empty</span><span class="p">))</span>
    <span class="nx">assertSlicesEqual</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">SlicesMerge</span><span class="p">(</span><span class="nx">empty</span><span class="p">,</span> <span class="nx">a</span><span class="p">))</span>

    <span class="nx">a</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
    <span class="nx">assertSlicesEqual</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">SlicesMerge</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">empty</span><span class="p">))</span>
    <span class="nx">assertSlicesEqual</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">SlicesMerge</span><span class="p">(</span><span class="nx">empty</span><span class="p">,</span> <span class="nx">a</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">TestSlicesMergeNegative</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// if os.Getenv("MY_ENVIRONMENT_VARIABLE") == "" {</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Skip</span><span class="p">(</span><span class="s">"skipping test: $MY_ENVIRONMENT_VARIABLE is not set"</span><span class="p">)</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>
    <span class="nx">a</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
    <span class="nx">b</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="o">-</span><span class="mi">2870837225030527764</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">}</span>
    <span class="nx">assertSlicesEqual</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="o">-</span><span class="mi">2870837225030527764</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="nx">SlicesMerge</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">))</span>
<span class="p">}</span>


<span class="c1">// Helper Functions</span>

<span class="kd">func</span> <span class="nx">assertSlicesEqual</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">,</span> <span class="nx">expected</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">result</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">DeepEqual</span><span class="p">(</span><span class="nx">expected</span><span class="p">,</span> <span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="s">"\nExpected:"</span><span class="p">,</span> <span class="nx">expected</span><span class="p">,</span> <span class="s">"\nReceived: "</span><span class="p">,</span> <span class="nx">result</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<blockquote>
<p>The idea is to have code that is testable, and just use Go code to write the tests (not another DomainSpecificLanguage to learn)</p>
</blockquote>
<ul>
<li><a href="https://golang.org/pkg/testing/">https://golang.org/pkg/testing/</a></li>
</ul>
<blockquote>
<p>Skipping tests is fairly important to applying logic to parts of the test suite (or maybe deferring paying some technical debt)</p>
<p>Parallel indicates the tests can run in parallel, not useful here but in larger test suites taking advantage of extra processor power (GOMAXPROCS) to speed up the feedback loop is always appreciated</p>
<p>Even in a statically compiled language making comparisons of lists of potentially nested objects is unguaranteed, but the reflection function DeepEqual does a best effort job</p>
</blockquote>
<ul>
<li><a href="https://golang.org/pkg/reflect/#DeepEqual">https://golang.org/pkg/reflect/#DeepEqual</a></li>
</ul>
<h4 id="running-a-specific-test">Running a specific test</h4>
<p><code>go test -v -run TestSlicesMergeHalf</code></p>
<blockquote>
<p>Getting verbose output and specifying tests is quite helpful when fixing a piece of code or test.  <strong>Note</strong> the run parameter takes a regular expression</p>
</blockquote>
<h4 id="test-coverage">Test Coverage</h4>
<p>Sometimes people talk about "test coverage" and while it's clear that 100% coverage is rarely possible (nor entirely desirable from the idea of diminishing returns and exponential growth in integration combinations outside of the simplest function) , it's still a useful metric/tool to discover if there's a chunk of code that's whistling in the wind.</p>
<p><code>go test -cover</code></p>
<blockquote>
<p>"coverage: 75.0% of statements"</p>
</blockquote>
<h3 id="subtests">Subtests</h3>
<p>Using the pattern of table driven tests improves the readability and extensibility of the "merge empty test" by applying "Don't Repeat Yourself" and removing the copy pasting of the driver function call.</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">"reflect"</span>
    <span class="s">"testing"</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">empty</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>

<span class="kd">func</span> <span class="nx">assertSlicesEqual</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">,</span> <span class="nx">expected</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">result</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">DeepEqual</span><span class="p">(</span><span class="nx">expected</span><span class="p">,</span> <span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="s">"\nExpected:"</span><span class="p">,</span> <span class="nx">expected</span><span class="p">,</span> <span class="s">"\nReceived: "</span><span class="p">,</span> <span class="nx">result</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// defining the test structure separately and clear naming helps readability</span>
<span class="kd">type</span> <span class="nx">slicesMergeTest</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">a</span>        <span class="p">[]</span><span class="kt">int</span>
    <span class="nx">b</span>        <span class="p">[]</span><span class="kt">int</span>
    <span class="nx">expected</span> <span class="p">[]</span><span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">TestSlicesMergeEmpty</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">testCases</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">slicesMergeTest</span><span class="p">{</span>
        <span class="p">{</span><span class="nx">a</span><span class="p">:</span> <span class="nx">empty</span><span class="p">,</span> <span class="nx">b</span><span class="p">:</span> <span class="nx">empty</span><span class="p">,</span> <span class="nx">expected</span><span class="p">:</span> <span class="nx">empty</span><span class="p">},</span>
        <span class="p">{</span><span class="nx">a</span><span class="p">:</span> <span class="nx">empty</span><span class="p">,</span> <span class="nx">b</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">expected</span><span class="p">:</span> <span class="nx">empty</span><span class="p">},</span>
        <span class="p">{</span><span class="nx">a</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">b</span><span class="p">:</span> <span class="nx">empty</span><span class="p">,</span> <span class="nx">expected</span><span class="p">:</span> <span class="nx">empty</span><span class="p">},</span>
        <span class="p">{</span><span class="nx">a</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">b</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">expected</span><span class="p">:</span> <span class="nx">empty</span><span class="p">},</span>
    <span class="p">}</span>

    <span class="c1">// Without subtests</span>
    <span class="c1">// for _, tc := range testCases {</span>
    <span class="c1">//  actual := SlicesMerge(tc.a, tc.b)</span>
    <span class="c1">//  assertSlicesEqual(t, tc.expected, actual)</span>
    <span class="c1">// }</span>

    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">tc</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">testCases</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">"%#v merged with %#v"</span><span class="p">,</span> <span class="nx">tc</span><span class="p">.</span><span class="nx">a</span><span class="p">,</span> <span class="nx">tc</span><span class="p">.</span><span class="nx">b</span><span class="p">),</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">actual</span> <span class="o">:=</span> <span class="nx">SlicesMerge</span><span class="p">(</span><span class="nx">tc</span><span class="p">.</span><span class="nx">a</span><span class="p">,</span> <span class="nx">tc</span><span class="p">.</span><span class="nx">b</span><span class="p">)</span>
            <span class="nx">assertSlicesEqual</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">tc</span><span class="p">.</span><span class="nx">expected</span><span class="p">,</span> <span class="nx">actual</span><span class="p">)</span>
        <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<blockquote>
<p>One variation with the "subtest" feature (which may apply more to benchmarks than straightforward unit tests) is not only that a fatal will not skip subsequent tests but that the output is more verbose</p>
</blockquote>
<div class="highlight"><pre><span></span>=== RUN   TestSlicesMergeEmpty
--- PASS: TestSlicesMergeEmpty (0.00s)
PASS
</pre></div>
<blockquote>
<p>With subtests...</p>
</blockquote>
<div class="highlight"><pre><span></span>=== RUN   TestSlicesMergeEmpty
=== RUN   TestSlicesMergeEmpty/[]int{}_merged_with_[]int{}
=== RUN   TestSlicesMergeEmpty/[]int{}_merged_with_[]int(nil)
=== RUN   TestSlicesMergeEmpty/[]int(nil)_merged_with_[]int{}
=== RUN   TestSlicesMergeEmpty/[]int(nil)_merged_with_[]int(nil)
--- PASS: TestSlicesMergeEmpty (0.00s)
    --- PASS: TestSlicesMergeEmpty/[]int{}_merged_with_[]int{} (0.00s)
    --- PASS: TestSlicesMergeEmpty/[]int{}_merged_with_[]int(nil) (0.00s)
    --- PASS: TestSlicesMergeEmpty/[]int(nil)_merged_with_[]int{} (0.00s)
    --- PASS: TestSlicesMergeEmpty/[]int(nil)_merged_with_[]int(nil) (0.00s)
PASS
</pre></div>
<blockquote>
<p>Making the "table" of inputs and outputs more obvious AND the output verbosity clearer seems like a small refinement but goes a long way to making production quality testing easier</p>
</blockquote>
<h4 id="running-a-specific-subtest">Running a specific subtest</h4>
<p><code>go test -v -run=TestSlicesMergeEmpty/"nil"</code></p>
<div class="highlight"><pre><span></span><span class="gd">--- PASS: TestSlicesMergeEmpty (0.00s)</span>
    --- PASS: TestSlicesMergeEmpty/[]int{}_merged_with_[]int(nil) (0.00s)
    --- PASS: TestSlicesMergeEmpty/[]int(nil)_merged_with_[]int{} (0.00s)
    --- PASS: TestSlicesMergeEmpty/[]int(nil)_merged_with_[]int(nil) (0.00s)
</pre></div>
<blockquote>
<p>Yes! You can pattern match on the string from the subtest table and only run a subset of subtests (mindblown)</p>
</blockquote>
<ul>
<li><a href="https://blog.golang.org/subtests">https://blog.golang.org/subtests</a></li>
<li><a href="http://dave.cheney.net/2013/06/09/writing-table-driven-tests-in-go">http://dave.cheney.net/2013/06/09/writing-table-driven-tests-in-go</a></li>
</ul>
<h2 id="benchmarking">Benchmarking</h2>
<p>Benchmarking is most useful if you're attempting to answer a question of two variations on how to implement something.</p>
<p>I suppose if you recorded every result and ran against exactly the same hardware you might be able to detect performance regressions, though I'd be worried about overly inconsistent/flaky results taking up way too much valuable time.</p>
<p>Inside of a _test.go file you can also write benchmark test functions, here is one of the classic questions of "concatenating strings in Go"</p>
<p>Here we compare the simplest concatenation of two strings and also the continued concatenation of many strings with either + or buffer.WriteString()</p>
<p>Create myconcat_test.go and execute the following with <code>go test -v -bench=.</code></p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">"bytes"</span>
    <span class="s">"testing"</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">MyConcatSimple</span><span class="p">(</span><span class="nx">a</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">MyConcatSimpleLooped</span><span class="p">(</span><span class="nx">a</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">101</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">a</span> <span class="o">+=</span> <span class="nx">b</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">a</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">MyConcatBytesBuffer</span><span class="p">(</span><span class="nx">a</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">buffer</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span>
    <span class="nx">buffer</span><span class="p">.</span><span class="nx">WriteString</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
    <span class="nx">buffer</span><span class="p">.</span><span class="nx">WriteString</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">buffer</span><span class="p">.</span><span class="nx">String</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">MyConcatBytesBufferLooped</span><span class="p">(</span><span class="nx">a</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">buffer</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span>
    <span class="nx">buffer</span><span class="p">.</span><span class="nx">WriteString</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">101</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">buffer</span><span class="p">.</span><span class="nx">WriteString</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">buffer</span><span class="p">.</span><span class="nx">String</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">BenchmarkConcatSimple</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">MyConcatSimple</span><span class="p">(</span><span class="s">"foo"</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">BenchmarkConcatSimpleLooped</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">MyConcatSimpleLooped</span><span class="p">(</span><span class="s">"foo"</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">BenchmarkConcatBytesBuffer</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">MyConcatBytesBuffer</span><span class="p">(</span><span class="s">"foo"</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">BenchmarkConcatBytesBufferLooped</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">MyConcatBytesBufferLooped</span><span class="p">(</span><span class="s">"foo"</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<blockquote>
<p>The b.N is automatically filled in by Go until the benchmark runner is "satisfied with stability" though you can create a wrapper function for the code under test if you wish to attempt more control over iterations</p>
<p>Remember that every benchmark is only valid against a specific set of hardware, operating system, libraries, etc. and with any changes (i.e. upgrade from Go 1.6 to 1.7) you may need to retest... unless you're just proving O(N) is better than O(N^2) ;)</p>
</blockquote>
<p>Oh right, the results...</p>
<div class="highlight"><pre><span></span>BenchmarkConcatSimple-4                 30000000                40.1 ns/op
BenchmarkConcatSimpleLooped-4             100000             20728 ns/op
BenchmarkConcatBytesBuffer-4             5000000               373 ns/op
BenchmarkConcatBytesBufferLooped-4        300000              7227 ns/op
</pre></div>
<blockquote>
<p>the iterations show that the simplest naive concatentation with + is very fast for a couple of small arguments (40 nanoseconds)</p>
<p>BUT if appending many (100+) items together buffer.Write() is better</p>
</blockquote>
<p>This example ignored all sorts of real world questions around how the strings are provided (i.e. a slice of strings might be better served by Join()) (or examine it's source code to see how they implement string concatenation!) , or memory consumption, etc.</p>
<ul>
<li><a href="http://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go">http://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go</a></li>
<li><a href="https://medium.com/hackintoshrao/daily-code-optimization-using-benchmarks-and-profiling-in-golang-gophercon-india-2016-talk-874c8b4dc3c5">https://medium.com/hackintoshrao/daily-code-optimization-using-benchmarks-and-profiling-in-golang-gophercon-india-2016-talk-874c8b4dc3c5</a></li>
<li><a href="https://golang.org/pkg/strings/#Join">https://golang.org/pkg/strings/#Join</a></li>
</ul>
<h4 id="running-specific-benchmarks">Running specific benchmarks</h4>
<p><code>go test -v -run=NOMATCH -bench=BenchmarkConcatSimple</code></p>
<blockquote>
<p>Since it is using the test runner the -run= regexp not matching allows you to skip any unit tests</p>
<p>-bench= can take a regexp to match only a subset of benchmark tests</p>
</blockquote>
<h2 id="profiling">Profiling</h2>
<p>TODO:</p>
<ul>
<li><a href="https://medium.com/tjholowaychuk/profiling-golang-851db2d9ae24">https://medium.com/tjholowaychuk/profiling-golang-851db2d9ae24</a></li>
<li><a href="http://blog.ralch.com/tutorial/golang-performance-and-memory-analysis/">http://blog.ralch.com/tutorial/golang-performance-and-memory-analysis/</a></li>
<li><a href="http://dave.cheney.net/2013/07/07/introducing-profile-super-simple-profiling-for-go-programs">http://dave.cheney.net/2013/07/07/introducing-profile-super-simple-profiling-for-go-programs</a></li>
<li><a href="https://blog.golang.org/profiling-go-programs">https://blog.golang.org/profiling-go-programs</a></li>
<li><a href="https://golang.org/pkg/net/http/pprof/">https://golang.org/pkg/net/http/pprof/</a></li>
<li><a href="https://golang.org/pkg/runtime/pprof/">https://golang.org/pkg/runtime/pprof/</a></li>
</ul>
<h2 id="go-fuzz-testing">Go Fuzz Testing</h2>
<p>Fuzz testing is furthering the principle of automation (and that computers are inherently better at some things than humans) to  have software discover edge cases for tests.</p>
<p>Basically the idea is to have software run over an extreme range or with randomness and then the edge cases that are discovered can be added into the test suite.  It has been used to enormously good effect on the Go standard library by Dmitry Vyukov.</p>
<p>One thing you start to see when attempting to apply it is that it really a tool for helping validate handling of a specific input.  It is not a magic wand to discover bugs. ;)</p>
<p>This kind of tool assisted exploratory testing is usually reserved for a more mature phase of a product (or in special use cases where there is high value in attempting to prove correctness).</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">TestSlicesMergeRandom</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">f</span> <span class="o">:=</span> <span class="nx">fuzz</span><span class="p">.</span><span class="nx">New</span><span class="p">()</span>
    <span class="kd">var</span> <span class="nx">randomSeed</span> <span class="kt">int</span>
    <span class="nx">f</span><span class="p">.</span><span class="nx">Fuzz</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">randomSeed</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">"random seed:"</span><span class="p">,</span> <span class="nx">randomSeed</span><span class="p">)</span>
    <span class="nx">r</span> <span class="o">:=</span> <span class="nx">rand</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">rand</span><span class="p">.</span><span class="nx">NewSource</span><span class="p">(</span><span class="nb">int64</span><span class="p">(</span><span class="nx">randomSeed</span><span class="p">)))</span>

    <span class="nx">xLength</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Int</span><span class="p">()</span> <span class="o">%</span> <span class="mi">5</span>
    <span class="nx">yLength</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Int</span><span class="p">()</span> <span class="o">%</span> <span class="mi">5</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">xLength</span><span class="p">,</span> <span class="nx">yLength</span><span class="p">)</span>
    <span class="kd">var</span> <span class="nx">x</span> <span class="p">[]</span><span class="kt">int</span>
    <span class="kd">var</span> <span class="nx">y</span> <span class="p">[]</span><span class="kt">int</span>

    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">xLength</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">r</span> <span class="kt">int</span>
        <span class="nx">f</span><span class="p">.</span><span class="nx">Fuzz</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">r</span><span class="p">)</span>
        <span class="nx">x</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">yLength</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">r</span> <span class="kt">int</span>
        <span class="nx">f</span><span class="p">.</span><span class="nx">Fuzz</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">r</span><span class="p">)</span>
        <span class="nx">y</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">sort</span><span class="p">.</span><span class="nx">Ints</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
    <span class="nx">sort</span><span class="p">.</span><span class="nx">Ints</span><span class="p">(</span><span class="nx">y</span><span class="p">)</span>
    <span class="nx">result</span> <span class="o">:=</span> <span class="nx">SlicesMerge</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span>
    <span class="nx">expected</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="o">...</span><span class="p">)</span>
    <span class="nx">sort</span><span class="p">.</span><span class="nx">Ints</span><span class="p">(</span><span class="nx">expected</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">DeepEqual</span><span class="p">(</span><span class="nx">expected</span><span class="p">,</span> <span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="s">"\nExpected:"</span><span class="p">,</span> <span class="nx">expected</span><span class="p">,</span> <span class="s">"\nReceived: "</span><span class="p">,</span> <span class="nx">result</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<blockquote>
<p>Seeding randomness is part of how this gofuzz library is used; the Vyukov version actually produces output that must be parsed separately.</p>
</blockquote>
<ul>
<li><a href="https://github.com/google/gofuzz">https://github.com/google/gofuzz</a></li>
<li><a href="https://github.com/dvyukov/go-fuzz">https://github.com/dvyukov/go-fuzz</a></li>
<li><a href="https://blog.cloudflare.com/dns-parser-meet-go-fuzzer">https://blog.cloudflare.com/dns-parser-meet-go-fuzzer</a></li>
<li>
<p><a href="https://medium.com/@dgryski/go-fuzz-github-com-arolek-ase-3c74d5a3150c#">https://medium.com/@dgryski/go-fuzz-github-com-arolek-ase-3c74d5a3150c#</a></p>
</li>
<li>
<p><a href="https://golang.org/pkg/math/rand/">https://golang.org/pkg/math/rand/</a></p>
</li>
<li><a href="https://golang.org/pkg/sort/">https://golang.org/pkg/sort/</a></li>
</ul>
            <aside>
            <hr/>
            <nav>
            <ul class="articles_timeline">
 
                <li class="previous_article">Â« <a href="https://blog.john-pfeiffer.com/golang-interfaces-stack-linked-list-queue-map-set/" title="Previous: Golang Interfaces Stack Linked List Queue Map Set">Golang Interfaces Stack Linked List Queue Map Set</a></li>
            </ul>
            </nav>
            </aside>
        </div>
        <section>
        <div class="span2" style="float:right;font-size:0.9em;">
 
            <h4>Published</h4>
            <time pubdate="pubdate" datetime="2016-10-22T20:44:00-07:00">Oct 22, 2016</time>
            <h4>Category</h4>
            <a class="category-link" href="/categories.html#programming-ref">programming</a> 
            <h4>~1768 words</h4>
            <h4>Tags</h4>
            <ul class="list-of-tags tags-in-article"> 
                <li><a href="/tags.html#benchmark-ref">benchmark
                    <span>1</span>
</a></li>
                <li><a href="/tags.html#go-ref">go
                    <span>5</span>
</a></li>
                <li><a href="/tags.html#golang-ref">golang
                    <span>4</span>
</a></li>
                <li><a href="/tags.html#profiling-ref">profiling
                    <span>1</span>
</a></li>
                <li><a href="/tags.html#subtests-ref">subtests
                    <span>1</span>
</a></li>
                <li><a href="/tags.html#tdd-ref">tdd
                    <span>4</span>
</a></li>
                <li><a href="/tags.html#testing-ref">testing
                    <span>6</span>
</a></li>
            </ul>

        </div>
        </section>
</div>
</article>
				</div>
				<div class="span1"></div>
			</div>
		</div>
    </div>
<footer>
<div id="footer">
    <ul class="footer-content">
    </ul>
</div>
</footer>            <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/2.3.1/js/bootstrap.min.js"></script>
        <script>
            function validateForm(query)
            {
                return (query.length > 0);
            }
        </script>

    </body>
</html>